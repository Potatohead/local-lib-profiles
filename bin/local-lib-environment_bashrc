#TODO
# - Going to have to look at the possibility of putting the current active
#   environments names somewhere which opens up the possibility of deactivating
#   and lets me stop people from deleting active environments and activating
#   something twice. Can also get it into the prompt somehow
# - existence of .modulebuildrc in a directory means its an environment


# Make sure there is a default value for WORKON_HOME.
# You can override this setting in your .bashrc.
if [ "$LOCAL_LIB_HOME" = "" ]
then
    export LOCAL_LIB_HOME="$HOME/.perl-environments"
fi

# Normalize the directory name in case it includes 
# relative path components.
LOCAL_LIB_HOME=$(sh -c 'cd "$LOCAL_LIB_HOME"; pwd')
export LOCAL_LIB_HOME

# Verify that the local lib home exists
function ll_verify_home () {
    if [ ! -d "$LOCAL_LIB_HOME" ]
    then
        echo "ERROR: local lib environments directory '$LOCAL_LIB_HOME' does not exist." >&2
        return 1
    fi
    return 0
}

# Verify that the named environment in the local lib home exists
function ll_verify_home_environment () {
    typeset env_name="$1"
    if [ "$env_name" = "" ]
    then
        echo "Please specify an enviroment." >&2
        return 1
    fi
    if [ ! -d "$LOCAL_LIB_HOME/$env_name" ]
    then
        echo "ERROR: Environment '$env_name' does not exist." >&2
        return 1
    fi
    return 0
}

# Verify that the active environment exists
function ll_verify_active_environment () {
    if [ ! -n "${PERL_ENV}" ] || [ ! -d "${PERL_ENV}" ]
    then
        echo "ERROR: no environment active, or active environment is missing" >&2
        return 1
    fi
    return 0
}

#changes directory to the currently active environment
function ll_cdenv () {
    ll_verify_active_environment || return 1
    cd $PERL_ENV/$1
}

# List the available environments.
function ll_show_workon_options () {
    ll_verify_home  || return 1
    # NOTE: DO NOT use ls here because colorized versions spew control characters
    #       into the output list.
    # echo seems a little faster than find, even with -depth 3.
    (cd "$LOCAL_LIB_HOME"; for f in */.modulebuildrc; do echo $f; done) | sed 's|^\./||' | sed 's|/.modulebuildrc||' | sort
}

# Create a new environment in local lib home
function ll_mkenv () {
    eval "envname=\$$#"
    if [ "$env_name" = "" ]
    then
        echo "Please specify an enviroment name." >&2
        return 1
    fi
    ll_verify_home || return 1
    perl -e "use local::lib::environment; local::lib::environment::make_environment(directory => '$LOCAL_LIB_HOME/$envname');"
}

# Run a hook script in the current shell
function ll_source_hook () {
    scriptname="$1"
    if [ -f "$scriptname" ]
    then
        source "$scriptname"
    fi
}

# Run a hook script in its own shell
function ll_run_hook () {
    scriptname="$1"
    shift
    if [ -x "$scriptname" ]
    then
        "$scriptname" "$@"
    fi
}

# Remove an existing environment from local lib home
function ll_rmenv () {
    typeset env_name="$1"
    ll_verify_home || return 1
    if [ "$env_name"  = "" ]
    then
        echo "Please specify an environment." >&2
        return 1
    fi
    
    ll_verify_home_environment $env_name || return 1
    env_dir="$LOCAL_LIB_HOME/$env_name"

    # check here if its the active environment somehow
    if [ "$PERL_ENV" = "$env_dir" ]
    then
        echo "ERROR: You cannot remove the active environment ('$env_name')." >&2
        echo "Either switch to another environment, or run 'deactivate'." >&2
        return 1
    fi
    
    rm -rf "$env_dir"
}

# takes an existing local-lib or local-lib-environment and upgrades its support
# scripts
function ll_upgrade_env () {
    typeset env_dir="$1"
    if [ "$env_dir" = "" ]
    then
        echo "Please specify an enviroment directory." >&2
        return 1
    fi
    if [ ! -d "${env_dir}" ]
    then
        echo "ERROR: the environment directory does not exist" >&2
        return 1
    fi

    ll_verify_home || return 1
    perl -e "use local::lib::environment; local::lib::environment::upgrade_environment(directory => '$env_dir');"
}

# Activate a named environment
function ll_workon () {
    typeset env_name="$1"
    if [ "$env_name" = "" ]
    then
        # Return the list of available environments
        ll_show_workon_options
        return 1
    fi

    ll_verify_home || return 1
    ll_verify_home_environment || return 1

    activate="$LOCAL_LIB_HOME/$env_name/bin/ll_activate"

    if [ ! -f "$activate" ]
    then
        echo "ERROR: Environment '$WORKON_HOME/$env_name' does not contain an activate script." >&2
        return 1
    fi

    # Deactivate any current environment "destructively"
    # before switching so we use our override function,
    # if it exists.
    type ll_deactivate >/dev/null 2>&1
    if [ $? -eq 0 ]
    then
        ll_deactivate
    fi
    
    source "$activate"

    # Save the deactivate function from virtualenv
    ll_saved_deactivate=$(typeset -f ll_deactivate)

    # Replace the deactivate() function with a wrapper.
    eval 'function ll_deactivate () {
        # Call the local hook before the global so we can undo
        # any settings made by the local postactivate first.
        ll_source_hook "$PERL_ENV/bin/ll_predeactivate"
        ll_source_hook "$LOCAL_LIB_HOME/ll_predeactivate"
        
        env_postdeactivate_hook="$PERL_ENV/bin/ll_postdeactivate"
        
        # Restore the original definition of deactivate
        eval "$ll_saved_deactivate"

        # Instead of recursing, this calls the now restored original function.
        ll_deactivate

        ll_source_hook "$env_postdeactivate_hook"
        ll_source_hook "$LOCAL_LIB_HOME/ll_postdeactivate"
    }'
    
    ll_source_hook "$LOCAL_LIB_HOME/ll_postactivate"

    ll_source_hook "$PERL_ENV/bin/ll_postactivate"    
    
	return 0
}

if [ -n "$BASH" ] ; then
    _perlenvs ()
    {
        local cur="${COMP_WORDS[COMP_CWORD]}"
        COMPREPLY=( $(compgen -W "`ll_show_workon_options`" -- ${cur}) )
    }

    _cdperlenv_complete ()
    {
        local cur="$2"
        # COMPREPLY=( $(compgen -d -- "${VIRTUAL_ENV}/${cur}" | sed -e "s@${VIRTUAL_ENV}/@@" ) )
        COMPREPLY=( $(ll_cdenv && compgen -d -- "${cur}" ) )
    }
    complete -o nospace -F _cdperlenv_complete -S/ ll_cdenv
    complete -o default -o nospace -F _perlenvs ll_workon
    complete -o default -o nospace -F _perlenvs ll_rmenv
elif [ -n "$ZSH_VERSION" ] ; then
    compctl -g "`ll_show_workon_options`" workon rmvirtualenv
fi

